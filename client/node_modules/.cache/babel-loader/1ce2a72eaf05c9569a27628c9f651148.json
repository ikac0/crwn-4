{"ast":null,"code":"import _regeneratorRuntime from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n Copyright 2018 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.mjs';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.mjs';\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport messages from './utils/messages.mjs';\nimport cacheOkAndOpaquePlugin from './plugins/cacheOkAndOpaquePlugin.mjs';\nimport './_version.mjs';\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * @memberof workbox.strategies\n */\n\nvar NetworkFirst = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options\n   * @param {string} options.cacheName Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link workbox.core.cacheNames}.\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} options.fetchOptions Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of all fetch() requests made by this strategy.\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   * @param {number} options.networkTimeoutSeconds If set, any network requests\n   * that fail to respond within the timeout will fallback to the cache.\n   *\n   * This option can be used to combat\n   * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n   * scenarios.\n   */\n  function NetworkFirst() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, NetworkFirst);\n\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n\n    if (options.plugins) {\n      var isUsingCacheWillUpdate = options.plugins.some(function (plugin) {\n        return !!plugin.cacheWillUpdate;\n      });\n      this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin].concat(_toConsumableArray(options.plugins));\n    } else {\n      // No plugins passed in, use the default plugin.\n      this._plugins = [cacheOkAndOpaquePlugin];\n    }\n\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._networkTimeoutSeconds) {\n        assert.isType(this._networkTimeoutSeconds, 'number', {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkFirst',\n          funcName: 'constructor',\n          paramName: 'networkTimeoutSeconds'\n        });\n      }\n    }\n\n    this._fetchOptions = options.fetchOptions || null;\n    this._matchOptions = options.matchOptions || null;\n  }\n  /**\n   * This method will perform a request strategy and follows an API that\n   * will work with the\n   * [Workbox Router]{@link workbox.routing.Router}.\n   *\n   * @param {Object} options\n   * @param {FetchEvent} options.event The fetch event to run this strategy\n   * against.\n   * @return {Promise<Response>}\n   */\n\n\n  _createClass(NetworkFirst, [{\n    key: \"handle\",\n    value: function () {\n      var _handle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var event;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                event = _ref.event;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  assert.isInstance(event, FetchEvent, {\n                    moduleName: 'workbox-strategies',\n                    className: 'NetworkFirst',\n                    funcName: 'handle',\n                    paramName: 'event'\n                  });\n                }\n\n                return _context.abrupt(\"return\", this.makeRequest({\n                  event: event,\n                  request: event.request\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handle(_x) {\n        return _handle.apply(this, arguments);\n      }\n\n      return handle;\n    }()\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n  }, {\n    key: \"makeRequest\",\n    value: function () {\n      var _makeRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n        var event, request, logs, promises, timeoutId, _this$_getTimeoutProm, id, promise, networkPromise, response, _iterator, _step, log;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                event = _ref2.event, request = _ref2.request;\n                logs = [];\n\n                if (typeof request === 'string') {\n                  request = new Request(request);\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  assert.isInstance(request, Request, {\n                    moduleName: 'workbox-strategies',\n                    className: 'NetworkFirst',\n                    funcName: 'handle',\n                    paramName: 'makeRequest'\n                  });\n                }\n\n                promises = [];\n\n                if (this._networkTimeoutSeconds) {\n                  _this$_getTimeoutProm = this._getTimeoutPromise({\n                    request: request,\n                    event: event,\n                    logs: logs\n                  }), id = _this$_getTimeoutProm.id, promise = _this$_getTimeoutProm.promise;\n                  timeoutId = id;\n                  promises.push(promise);\n                }\n\n                networkPromise = this._getNetworkPromise({\n                  timeoutId: timeoutId,\n                  request: request,\n                  event: event,\n                  logs: logs\n                });\n                promises.push(networkPromise); // Promise.race() will resolve as soon as the first promise resolves.\n\n                _context2.next = 10;\n                return Promise.race(promises);\n\n              case 10:\n                response = _context2.sent;\n\n                if (response) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                _context2.next = 14;\n                return networkPromise;\n\n              case 14:\n                response = _context2.sent;\n\n              case 15:\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n                  _iterator = _createForOfIteratorHelper(logs);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      log = _step.value;\n                      logger.log(log);\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n\n                  messages.printFinalResponse(response);\n                  logger.groupEnd();\n                }\n\n                return _context2.abrupt(\"return\", response);\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function makeRequest(_x2) {\n        return _makeRequest.apply(this, arguments);\n      }\n\n      return makeRequest;\n    }()\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getTimeoutPromise\",\n    value: function _getTimeoutPromise(_ref3) {\n      var _this = this;\n\n      var request = _ref3.request,\n          logs = _ref3.logs,\n          event = _ref3.event;\n      var timeoutId;\n      var timeoutPromise = new Promise(function (resolve) {\n        var onNetworkTimeout = /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n            return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    if (process.env.NODE_ENV !== 'production') {\n                      logs.push(\"Timing out the network response at \" + \"\".concat(_this._networkTimeoutSeconds, \" seconds.\"));\n                    }\n\n                    _context3.t0 = resolve;\n                    _context3.next = 4;\n                    return _this._respondFromCache({\n                      request: request,\n                      event: event\n                    });\n\n                  case 4:\n                    _context3.t1 = _context3.sent;\n                    (0, _context3.t0)(_context3.t1);\n\n                  case 6:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, _callee3);\n          }));\n\n          return function onNetworkTimeout() {\n            return _ref4.apply(this, arguments);\n          };\n        }();\n\n        timeoutId = setTimeout(onNetworkTimeout, _this._networkTimeoutSeconds * 1000);\n      });\n      return {\n        promise: timeoutPromise,\n        id: timeoutId\n      };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getNetworkPromise\",\n    value: function () {\n      var _getNetworkPromise2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n        var timeoutId, request, logs, event, error, response, responseClone, cachePut;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                timeoutId = _ref5.timeoutId, request = _ref5.request, logs = _ref5.logs, event = _ref5.event;\n                _context4.prev = 1;\n                _context4.next = 4;\n                return fetchWrapper.fetch({\n                  request: request,\n                  event: event,\n                  fetchOptions: this._fetchOptions,\n                  plugins: this._plugins\n                });\n\n              case 4:\n                response = _context4.sent;\n                _context4.next = 10;\n                break;\n\n              case 7:\n                _context4.prev = 7;\n                _context4.t0 = _context4[\"catch\"](1);\n                error = _context4.t0;\n\n              case 10:\n                if (timeoutId) {\n                  clearTimeout(timeoutId);\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  if (response) {\n                    logs.push(\"Got response from network.\");\n                  } else {\n                    logs.push(\"Unable to get a response from the network. Will respond \" + \"with a cached response.\");\n                  }\n                }\n\n                if (!(error || !response)) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                _context4.next = 15;\n                return this._respondFromCache({\n                  request: request,\n                  event: event\n                });\n\n              case 15:\n                response = _context4.sent;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  if (response) {\n                    logs.push(\"Found a cached response in the '\".concat(this._cacheName, \"'\") + \" cache.\");\n                  } else {\n                    logs.push(\"No response found in the '\".concat(this._cacheName, \"' cache.\"));\n                  }\n                }\n\n                _context4.next = 22;\n                break;\n\n              case 19:\n                // Keep the service worker alive while we put the request in the cache\n                responseClone = response.clone();\n                cachePut = cacheWrapper.put({\n                  cacheName: this._cacheName,\n                  request: request,\n                  response: responseClone,\n                  event: event,\n                  plugins: this._plugins\n                });\n\n                if (event) {\n                  try {\n                    // The event has been responded to so we can keep the SW alive to\n                    // respond to the request\n                    event.waitUntil(cachePut);\n                  } catch (err) {\n                    if (process.env.NODE_ENV !== 'production') {\n                      logger.warn(\"Unable to ensure service worker stays alive when \" + \"updating cache for '\".concat(getFriendlyURL(event.request.url), \"'.\"));\n                    }\n                  }\n                }\n\n              case 22:\n                return _context4.abrupt(\"return\", response);\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 7]]);\n      }));\n\n      function _getNetworkPromise(_x3) {\n        return _getNetworkPromise2.apply(this, arguments);\n      }\n\n      return _getNetworkPromise;\n    }()\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_respondFromCache\",\n    value: function _respondFromCache(_ref6) {\n      var event = _ref6.event,\n          request = _ref6.request;\n      return cacheWrapper.match({\n        cacheName: this._cacheName,\n        request: request,\n        event: event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n    }\n  }]);\n\n  return NetworkFirst;\n}();\n\nexport { NetworkFirst };","map":null,"metadata":{},"sourceType":"module"}