{"ast":null,"code":"import _classCallCheck from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\nimport { NavigationRoute } from './NavigationRoute.mjs';\nimport { RegExpRoute } from './RegExpRoute.mjs';\nimport { Router } from './Router.mjs';\nimport { Route } from './Route.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport './_version.mjs';\n\nif (process.env.NODE_ENV !== 'production') {\n  assert.isSwEnv('workbox-routing');\n}\n/**\n * @private\n */\n\n\nvar DefaultRouter = /*#__PURE__*/function (_Router) {\n  _inherits(DefaultRouter, _Router);\n\n  function DefaultRouter() {\n    _classCallCheck(this, DefaultRouter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DefaultRouter).apply(this, arguments));\n  }\n\n  _createClass(DefaultRouter, [{\n    key: \"registerRoute\",\n\n    /**\n     * Easily register a RegExp, string, or function with a caching\n     * strategy to the Router.\n     *\n     * This method will generate a Route for you if needed and\n     * call [Router.registerRoute()]{@link\n     * workbox.routing.Router#registerRoute}.\n     *\n     * @param {\n     * RegExp|\n     * string|\n     * workbox.routing.Route~matchCallback|\n     * workbox.routing.Route\n     * } capture\n     * If the capture param is a `Route`, all other arguments will be ignored.\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     * @return {workbox.routing.Route} The generated `Route`(Useful for\n     * unregistering).\n     *\n     * @alias workbox.routing.registerRoute\n     */\n    value: function registerRoute(capture, handler) {\n      var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET';\n      var route;\n\n      if (typeof capture === 'string') {\n        var captureUrl = new URL(capture, location);\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n            throw new WorkboxError('invalid-string', {\n              moduleName: 'workbox-routing',\n              className: 'DefaultRouter',\n              funcName: 'registerRoute',\n              paramName: 'capture'\n            });\n          } // We want to check if Express-style wildcards are in the pathname only.\n          // TODO: Remove this log message in v4.\n\n\n          var valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture; // See https://github.com/pillarjs/path-to-regexp#parameters\n\n          var wildcards = '[*:?+]';\n\n          if (valueToCheck.match(new RegExp(\"\".concat(wildcards)))) {\n            logger.debug(\"The '$capture' parameter contains an Express-style wildcard \" + \"character (\".concat(wildcards, \"). Strings are now always interpreted as \") + \"exact matches; use a RegExp for partial or wildcard matches.\");\n          }\n        }\n\n        var matchCallback = function matchCallback(_ref) {\n          var url = _ref.url;\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n              logger.debug(\"\".concat(capture, \" only partially matches the cross-origin URL \") + \"\".concat(url, \". This route will only handle cross-origin requests \") + \"if they match the entire URL.\");\n            }\n          }\n\n          return url.href === captureUrl.href;\n        };\n\n        route = new Route(matchCallback, handler, method);\n      } else if (capture instanceof RegExp) {\n        route = new RegExpRoute(capture, handler, method);\n      } else if (typeof capture === 'function') {\n        route = new Route(capture, handler, method);\n      } else if (capture instanceof Route) {\n        route = capture;\n      } else {\n        throw new WorkboxError('unsupported-route-type', {\n          moduleName: 'workbox-routing',\n          className: 'DefaultRouter',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n\n      _get(_getPrototypeOf(DefaultRouter.prototype), \"registerRoute\", this).call(this, route);\n\n      return route;\n    }\n    /**\n     * Register a route that will return a precached file for a navigation\n     * request. This is useful for the\n     * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\n     *\n     * This method will generate a\n     * [NavigationRoute]{@link workbox.routing.NavigationRoute}\n     * and call\n     * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute}\n     * .\n     *\n     * @param {string} cachedAssetUrl\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to precache cache name provided by\n     * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\n     * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\n     * match, the route will not handle the request (even if a whitelist entry\n     * matches).\n     * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n     * match the URL's pathname and search parameter, the route will handle the\n     * request (assuming the blacklist doesn't match).\n     * @return {workbox.routing.NavigationRoute} Returns the generated\n     * Route.\n     *\n     * @alias workbox.routing.registerNavigationRoute\n     */\n\n  }, {\n    key: \"registerNavigationRoute\",\n    value: function registerNavigationRoute(cachedAssetUrl) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(cachedAssetUrl, 'string', {\n          moduleName: 'workbox-routing',\n          className: '[default export]',\n          funcName: 'registerNavigationRoute',\n          paramName: 'cachedAssetUrl'\n        });\n      }\n\n      var cacheName = cacheNames.getPrecacheName(options.cacheName);\n\n      var handler = function handler() {\n        return caches.match(cachedAssetUrl, {\n          cacheName: cacheName\n        }).then(function (response) {\n          if (response) {\n            return response;\n          } // This shouldn't normally happen, but there are edge cases:\n          // https://github.com/GoogleChrome/workbox/issues/1441\n\n\n          throw new Error(\"The cache \".concat(cacheName, \" did not have an entry for \") + \"\".concat(cachedAssetUrl, \".\"));\n        }).catch(function (error) {\n          // If there's either a cache miss, or the caches.match() call threw\n          // an exception, then attempt to fulfill the navigation request with\n          // a response from the network rather than leaving the user with a\n          // failed navigation.\n          if (process.env.NODE_ENV !== 'production') {\n            logger.debug(\"Unable to respond to navigation request with cached \" + \"response: \".concat(error.message, \". Falling back to network.\"));\n          } // This might still fail if the browser is offline...\n\n\n          return fetch(cachedAssetUrl);\n        });\n      };\n\n      var route = new NavigationRoute(handler, {\n        whitelist: options.whitelist,\n        blacklist: options.blacklist\n      });\n\n      _get(_getPrototypeOf(DefaultRouter.prototype), \"registerRoute\", this).call(this, route);\n\n      return route;\n    }\n  }]);\n\n  return DefaultRouter;\n}(Router);\n\nvar router = new DefaultRouter(); // By default, register a fetch event listener that will respond to a request\n// only if there's a matching route.\n\nself.addEventListener('fetch', function (event) {\n  var responsePromise = router.handleRequest(event);\n\n  if (responsePromise) {\n    event.respondWith(responsePromise);\n  }\n});\nexport default router;","map":null,"metadata":{},"sourceType":"module"}