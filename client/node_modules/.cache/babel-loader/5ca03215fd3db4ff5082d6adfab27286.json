{"ast":null,"code":"import _regeneratorRuntime from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nvar wrappedFetch = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var request, fetchOptions, event, _ref$plugins, plugins, possiblePreloadResponse, failedFetchPlugins, originalRequest, _iterator, _step, plugin, pluginMethod, requestClone, pluginFilteredRequest, fetchResponse, _iterator2, _step2, _plugin, _iterator3, _step3, _plugin2;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            request = _ref.request, fetchOptions = _ref.fetchOptions, event = _ref.event, _ref$plugins = _ref.plugins, plugins = _ref$plugins === void 0 ? [] : _ref$plugins;\n\n            if (typeof request === 'string') {\n              request = new Request(request);\n            } // We *should* be able to call `await event.preloadResponse` even if it's\n            // undefined, but for some reason, doing so leads to errors in our Node unit\n            // tests. To work around that, explicitly check preloadResponse's value first.\n\n\n            if (!(event instanceof FetchEvent && event.preloadResponse)) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 5;\n            return event.preloadResponse;\n\n          case 5:\n            possiblePreloadResponse = _context.sent;\n\n            if (!possiblePreloadResponse) {\n              _context.next = 9;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.log(\"Using a preloaded navigation response for \" + \"'\".concat(getFriendlyURL(request.url), \"'\"));\n            }\n\n            return _context.abrupt(\"return\", possiblePreloadResponse);\n\n          case 9:\n            if (process.env.NODE_ENV !== 'production') {\n              assert.isInstance(request, Request, {\n                paramName: 'request',\n                expectedClass: Request,\n                moduleName: 'workbox-core',\n                className: 'fetchWrapper',\n                funcName: 'wrappedFetch'\n              });\n            }\n\n            failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\"\n            /* FETCH_DID_FAIL */\n            ); // If there is a fetchDidFail plugin, we need to save a clone of the\n            // original request before it's either modified by a requestWillFetch\n            // plugin or before the original request's body is consumed via fetch().\n\n            originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n            _context.prev = 12;\n            _iterator = _createForOfIteratorHelper(plugins);\n            _context.prev = 14;\n\n            _iterator.s();\n\n          case 16:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 27;\n              break;\n            }\n\n            plugin = _step.value;\n\n            if (!(\"requestWillFetch\"\n            /* REQUEST_WILL_FETCH */\n            in plugin)) {\n              _context.next = 25;\n              break;\n            }\n\n            pluginMethod = plugin[\"requestWillFetch\"\n            /* REQUEST_WILL_FETCH */\n            ];\n            requestClone = request.clone();\n            _context.next = 23;\n            return pluginMethod.call(plugin, {\n              request: requestClone,\n              event: event\n            });\n\n          case 23:\n            request = _context.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (request) {\n                assert.isInstance(request, Request, {\n                  moduleName: 'Plugin',\n                  funcName: \"cachedResponseWillBeUsed\"\n                  /* CACHED_RESPONSE_WILL_BE_USED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 25:\n            _context.next = 16;\n            break;\n\n          case 27:\n            _context.next = 32;\n            break;\n\n          case 29:\n            _context.prev = 29;\n            _context.t0 = _context[\"catch\"](14);\n\n            _iterator.e(_context.t0);\n\n          case 32:\n            _context.prev = 32;\n\n            _iterator.f();\n\n            return _context.finish(32);\n\n          case 35:\n            _context.next = 40;\n            break;\n\n          case 37:\n            _context.prev = 37;\n            _context.t1 = _context[\"catch\"](12);\n            throw new WorkboxError('plugin-error-request-will-fetch', {\n              thrownError: _context.t1\n            });\n\n          case 40:\n            // The request can be altered by plugins with `requestWillFetch` making\n            // the original request (Most likely from a `fetch` event) to be different\n            // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n            pluginFilteredRequest = request.clone();\n            _context.prev = 41;\n\n            if (!(request.mode === 'navigate')) {\n              _context.next = 48;\n              break;\n            }\n\n            _context.next = 45;\n            return fetch(request);\n\n          case 45:\n            fetchResponse = _context.sent;\n            _context.next = 51;\n            break;\n\n          case 48:\n            _context.next = 50;\n            return fetch(request, fetchOptions);\n\n          case 50:\n            fetchResponse = _context.sent;\n\n          case 51:\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' returned a response with \") + \"status '\".concat(fetchResponse.status, \"'.\"));\n            }\n\n            _iterator2 = _createForOfIteratorHelper(plugins);\n            _context.prev = 53;\n\n            _iterator2.s();\n\n          case 55:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 64;\n              break;\n            }\n\n            _plugin = _step2.value;\n\n            if (!(\"fetchDidSucceed\"\n            /* FETCH_DID_SUCCEED */\n            in _plugin)) {\n              _context.next = 62;\n              break;\n            }\n\n            _context.next = 60;\n            return _plugin[\"fetchDidSucceed\"\n            /* FETCH_DID_SUCCEED */\n            ].call(_plugin, {\n              event: event,\n              request: pluginFilteredRequest,\n              response: fetchResponse\n            });\n\n          case 60:\n            fetchResponse = _context.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (fetchResponse) {\n                assert.isInstance(fetchResponse, Response, {\n                  moduleName: 'Plugin',\n                  funcName: \"fetchDidSucceed\"\n                  /* FETCH_DID_SUCCEED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 62:\n            _context.next = 55;\n            break;\n\n          case 64:\n            _context.next = 69;\n            break;\n\n          case 66:\n            _context.prev = 66;\n            _context.t2 = _context[\"catch\"](53);\n\n            _iterator2.e(_context.t2);\n\n          case 69:\n            _context.prev = 69;\n\n            _iterator2.f();\n\n            return _context.finish(69);\n\n          case 72:\n            return _context.abrupt(\"return\", fetchResponse);\n\n          case 75:\n            _context.prev = 75;\n            _context.t3 = _context[\"catch\"](41);\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' threw an error.\"), _context.t3);\n            }\n\n            _iterator3 = _createForOfIteratorHelper(failedFetchPlugins);\n            _context.prev = 79;\n\n            _iterator3.s();\n\n          case 81:\n            if ((_step3 = _iterator3.n()).done) {\n              _context.next = 87;\n              break;\n            }\n\n            _plugin2 = _step3.value;\n            _context.next = 85;\n            return _plugin2[\"fetchDidFail\"\n            /* FETCH_DID_FAIL */\n            ].call(_plugin2, {\n              error: _context.t3,\n              event: event,\n              originalRequest: originalRequest.clone(),\n              request: pluginFilteredRequest.clone()\n            });\n\n          case 85:\n            _context.next = 81;\n            break;\n\n          case 87:\n            _context.next = 92;\n            break;\n\n          case 89:\n            _context.prev = 89;\n            _context.t4 = _context[\"catch\"](79);\n\n            _iterator3.e(_context.t4);\n\n          case 92:\n            _context.prev = 92;\n\n            _iterator3.f();\n\n            return _context.finish(92);\n\n          case 95:\n            throw _context.t3;\n\n          case 96:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[12, 37], [14, 29, 32, 35], [41, 75], [53, 66, 69, 72], [79, 89, 92, 95]]);\n  }));\n\n  return function wrappedFetch(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar fetchWrapper = {\n  fetch: wrappedFetch\n};\nexport { fetchWrapper };","map":null,"metadata":{},"sourceType":"module"}