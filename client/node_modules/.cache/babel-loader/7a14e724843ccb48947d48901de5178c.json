{"ast":null,"code":"import _slicedToArray from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.mjs';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.mjs';\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport PrecacheEntry from '../models/PrecacheEntry.mjs';\nimport PrecachedDetailsModel from '../models/PrecachedDetailsModel.mjs';\nimport showWarningsIfNeeded from '../utils/showWarningsIfNeeded.mjs';\nimport printInstallDetails from '../utils/printInstallDetails.mjs';\nimport printCleanupDetails from '../utils/printCleanupDetails.mjs';\nimport cleanRedirect from '../utils/cleanRedirect.mjs';\nimport '../_version.mjs';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox.precaching\n */\n\nvar PrecacheController = /*#__PURE__*/function () {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} cacheName\n   */\n  function PrecacheController(cacheName) {\n    _classCallCheck(this, PrecacheController);\n\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._entriesToCacheMap = new Map();\n    this._precacheDetailsModel = new PrecachedDetailsModel(this._cacheName);\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to\n   * precache.\n   */\n\n\n  _createClass(PrecacheController, [{\n    key: \"addToCacheList\",\n    value: function addToCacheList(entries) {\n      var _this = this;\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(entries, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'addToCacheList',\n          paramName: 'entries'\n        });\n      }\n\n      entries.map(function (userEntry) {\n        _this._addEntryToCacheList(_this._parseEntry(userEntry));\n      });\n    }\n    /**\n     * This method returns a precache entry.\n     *\n     * @private\n     * @param {string|Object} input\n     * @return {PrecacheEntry}\n     */\n\n  }, {\n    key: \"_parseEntry\",\n    value: function _parseEntry(input) {\n      switch (typeof input) {\n        case 'string':\n          {\n            if (process.env.NODE_ENV !== 'production') {\n              if (input.length === 0) {\n                throw new WorkboxError('add-to-cache-list-unexpected-type', {\n                  entry: input\n                });\n              }\n            }\n\n            return new PrecacheEntry(input, input, input);\n          }\n\n        case 'object':\n          {\n            if (process.env.NODE_ENV !== 'production') {\n              if (!input || !input.url) {\n                throw new WorkboxError('add-to-cache-list-unexpected-type', {\n                  entry: input\n                });\n              }\n            }\n\n            return new PrecacheEntry(input, input.url, input.revision || input.url, !!input.revision);\n          }\n\n        default:\n          throw new WorkboxError('add-to-cache-list-unexpected-type', {\n            entry: input\n          });\n      }\n    }\n    /**\n     * Adds an entry to the precache list, accounting for possible duplicates.\n     *\n     * @private\n     * @param {PrecacheEntry} entryToAdd\n     */\n\n  }, {\n    key: \"_addEntryToCacheList\",\n    value: function _addEntryToCacheList(entryToAdd) {\n      // Check if the entry is already part of the map\n      var existingEntry = this._entriesToCacheMap.get(entryToAdd._entryId);\n\n      if (!existingEntry) {\n        this._entriesToCacheMap.set(entryToAdd._entryId, entryToAdd);\n\n        return;\n      } // Duplicates are fine, but make sure the revision information\n      // is the same.\n\n\n      if (existingEntry._revision !== entryToAdd._revision) {\n        throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: existingEntry._originalInput,\n          secondEntry: entryToAdd._originalInput\n        });\n      }\n    }\n    /**\n     * Call this method from a service work install event to start\n     * precaching assets.\n     *\n     * @param {Object} options\n     * @param {boolean} [options.suppressWarnings] Suppress warning messages.\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     *     and caching during install.\n     * @return {Promise<workbox.precaching.InstallResult>}\n     */\n\n  }, {\n    key: \"install\",\n    value: function () {\n      var _install = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var _ref,\n            _ref$suppressWarnings,\n            suppressWarnings,\n            event,\n            plugins,\n            tempCache,\n            requests,\n            entriesToPrecache,\n            entriesAlreadyPrecached,\n            _iterator,\n            _step,\n            precacheEntry,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref$suppressWarnings = _ref.suppressWarnings, suppressWarnings = _ref$suppressWarnings === void 0 ? false : _ref$suppressWarnings, event = _ref.event, plugins = _ref.plugins;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  if (suppressWarnings !== true) {\n                    showWarningsIfNeeded(this._entriesToCacheMap);\n                  }\n\n                  if (plugins) {\n                    assert.isArray(plugins, {\n                      moduleName: 'workbox-precaching',\n                      className: 'PrecacheController',\n                      funcName: 'install',\n                      paramName: 'plugins'\n                    });\n                  }\n                } // Empty the temporary cache.\n                // NOTE: We remove all entries instead of deleting the cache as the cache\n                // may be marked for deletion but still exist until a later stage\n                // resulting in unexpected behavior of being deletect when all references\n                // are dropped.\n                // https://github.com/GoogleChrome/workbox/issues/1368\n\n\n                _context.next = 4;\n                return caches.open(this._getTempCacheName());\n\n              case 4:\n                tempCache = _context.sent;\n                _context.next = 7;\n                return tempCache.keys();\n\n              case 7:\n                requests = _context.sent;\n                _context.next = 10;\n                return Promise.all(requests.map(function (request) {\n                  return tempCache.delete(request);\n                }));\n\n              case 10:\n                entriesToPrecache = [];\n                entriesAlreadyPrecached = [];\n                _iterator = _createForOfIteratorHelper(this._entriesToCacheMap.values());\n                _context.prev = 13;\n\n                _iterator.s();\n\n              case 15:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 26;\n                  break;\n                }\n\n                precacheEntry = _step.value;\n                _context.next = 19;\n                return this._precacheDetailsModel._isEntryCached(this._cacheName, precacheEntry);\n\n              case 19:\n                if (!_context.sent) {\n                  _context.next = 23;\n                  break;\n                }\n\n                entriesAlreadyPrecached.push(precacheEntry);\n                _context.next = 24;\n                break;\n\n              case 23:\n                entriesToPrecache.push(precacheEntry);\n\n              case 24:\n                _context.next = 15;\n                break;\n\n              case 26:\n                _context.next = 31;\n                break;\n\n              case 28:\n                _context.prev = 28;\n                _context.t0 = _context[\"catch\"](13);\n\n                _iterator.e(_context.t0);\n\n              case 31:\n                _context.prev = 31;\n\n                _iterator.f();\n\n                return _context.finish(31);\n\n              case 34:\n                _context.next = 36;\n                return Promise.all(entriesToPrecache.map(function (precacheEntry) {\n                  return _this2._cacheEntryInTemp({\n                    event: event,\n                    plugins: plugins,\n                    precacheEntry: precacheEntry\n                  });\n                }));\n\n              case 36:\n                if (process.env.NODE_ENV !== 'production') {\n                  printInstallDetails(entriesToPrecache, entriesAlreadyPrecached);\n                }\n\n                return _context.abrupt(\"return\", {\n                  updatedEntries: entriesToPrecache,\n                  notUpdatedEntries: entriesAlreadyPrecached\n                });\n\n              case 38:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[13, 28, 31, 34]]);\n      }));\n\n      function install() {\n        return _install.apply(this, arguments);\n      }\n\n      return install;\n    }()\n    /**\n     * Takes the current set of temporary files and moves them to the final\n     * cache, deleting the temporary cache once copying is complete.\n     *\n     * @param {Object} options\n     * @param {Array<Object>} options.plugins Plugins to be used for fetching\n     * and caching during install.\n     * @return {\n     * Promise<workbox.precaching.CleanupResult>}\n     * Resolves with an object containing details of the deleted cache requests\n     * and precache revision details.\n     */\n\n  }, {\n    key: \"activate\",\n    value: function () {\n      var _activate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var options,\n            tempCache,\n            requests,\n            _iterator2,\n            _step2,\n            request,\n            response,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n                _context2.next = 3;\n                return caches.open(this._getTempCacheName());\n\n              case 3:\n                tempCache = _context2.sent;\n                _context2.next = 6;\n                return tempCache.keys();\n\n              case 6:\n                requests = _context2.sent;\n                // Process each request/response one at a time, deleting the temporary entry\n                // when done, to help avoid triggering quota errors.\n                _iterator2 = _createForOfIteratorHelper(requests);\n                _context2.prev = 8;\n\n                _iterator2.s();\n\n              case 10:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                request = _step2.value;\n                _context2.next = 14;\n                return tempCache.match(request);\n\n              case 14:\n                response = _context2.sent;\n                _context2.next = 17;\n                return cacheWrapper.put({\n                  cacheName: this._cacheName,\n                  request: request,\n                  response: response,\n                  plugins: options.plugins\n                });\n\n              case 17:\n                _context2.next = 19;\n                return tempCache.delete(request);\n\n              case 19:\n                _context2.next = 10;\n                break;\n\n              case 21:\n                _context2.next = 26;\n                break;\n\n              case 23:\n                _context2.prev = 23;\n                _context2.t0 = _context2[\"catch\"](8);\n\n                _iterator2.e(_context2.t0);\n\n              case 26:\n                _context2.prev = 26;\n\n                _iterator2.f();\n\n                return _context2.finish(26);\n\n              case 29:\n                return _context2.abrupt(\"return\", this._cleanup());\n\n              case 30:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 23, 26, 29]]);\n      }));\n\n      function activate() {\n        return _activate.apply(this, arguments);\n      }\n\n      return activate;\n    }()\n    /**\n     * Returns the name of the temporary cache.\n     *\n     * @return {string}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getTempCacheName\",\n    value: function _getTempCacheName() {\n      return \"\".concat(this._cacheName, \"-temp\");\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response\n     * is valid.\n     *\n     * @private\n     * @param {Object} options\n     * @param {BaseCacheEntry} options.precacheEntry The entry to fetch and cache.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     *     fetch and caching.\n     * @return {Promise<boolean>} Returns a promise that resolves once the entry\n     *     has been fetched and cached or skipped if no update is needed. The\n     *     promise resolves with true if the entry was cached / updated and\n     *     false if the entry is already cached and up-to-date.\n     */\n\n  }, {\n    key: \"_cacheEntryInTemp\",\n    value: function () {\n      var _cacheEntryInTemp2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref2) {\n        var precacheEntry, event, plugins, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                precacheEntry = _ref2.precacheEntry, event = _ref2.event, plugins = _ref2.plugins;\n                _context3.next = 3;\n                return fetchWrapper.fetch({\n                  request: precacheEntry._networkRequest,\n                  event: event,\n                  fetchOptions: null,\n                  plugins: plugins\n                });\n\n              case 3:\n                response = _context3.sent;\n\n                if (!response.redirected) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                _context3.next = 7;\n                return cleanRedirect(response);\n\n              case 7:\n                response = _context3.sent;\n\n              case 8:\n                _context3.next = 10;\n                return cacheWrapper.put({\n                  cacheName: this._getTempCacheName(),\n                  request: precacheEntry._cacheRequest,\n                  response: response,\n                  event: event,\n                  plugins: plugins\n                });\n\n              case 10:\n                _context3.next = 12;\n                return this._precacheDetailsModel._addEntry(precacheEntry);\n\n              case 12:\n                return _context3.abrupt(\"return\", true);\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _cacheEntryInTemp(_x) {\n        return _cacheEntryInTemp2.apply(this, arguments);\n      }\n\n      return _cacheEntryInTemp;\n    }()\n    /**\n     * Compare the URLs and determines which assets are no longer required\n     * in the cache.\n     *\n     * This should be called in the service worker activate event.\n     *\n     * @return {\n     * Promise<workbox.precaching.CleanupResult>}\n     * Resolves with an object containing details of the deleted cache requests\n     * and precache revision details.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_cleanup\",\n    value: function () {\n      var _cleanup2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var expectedCacheUrls, _yield$Promise$all, _yield$Promise$all2, deletedCacheRequests, deletedRevisionDetails;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                expectedCacheUrls = [];\n\n                this._entriesToCacheMap.forEach(function (entry) {\n                  var fullUrl = new URL(entry._cacheRequest.url, location).toString();\n                  expectedCacheUrls.push(fullUrl);\n                });\n\n                _context4.next = 4;\n                return Promise.all([this._cleanupCache(expectedCacheUrls), this._cleanupDetailsModel(expectedCacheUrls)]);\n\n              case 4:\n                _yield$Promise$all = _context4.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                deletedCacheRequests = _yield$Promise$all2[0];\n                deletedRevisionDetails = _yield$Promise$all2[1];\n\n                if (process.env.NODE_ENV !== 'production') {\n                  printCleanupDetails(deletedCacheRequests, deletedRevisionDetails);\n                }\n\n                return _context4.abrupt(\"return\", {\n                  deletedCacheRequests: deletedCacheRequests,\n                  deletedRevisionDetails: deletedRevisionDetails\n                });\n\n              case 10:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _cleanup() {\n        return _cleanup2.apply(this, arguments);\n      }\n\n      return _cleanup;\n    }()\n    /**\n     * Goes through all the cache entries and removes any that are\n     * outdated.\n     *\n     * @private\n     * @param {Array<string>} expectedCacheUrls Array of URLs that are\n     * expected to be cached.\n     * @return {Promise<Array<string>>} Resolves to an array of URLs\n     * of cached requests that were deleted.\n     */\n\n  }, {\n    key: \"_cleanupCache\",\n    value: function () {\n      var _cleanupCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(expectedCacheUrls) {\n        var cache, cachedRequests, cachedRequestsToDelete;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return caches.has(this._cacheName);\n\n              case 2:\n                if (_context5.sent) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", []);\n\n              case 4:\n                _context5.next = 6;\n                return caches.open(this._cacheName);\n\n              case 6:\n                cache = _context5.sent;\n                _context5.next = 9;\n                return cache.keys();\n\n              case 9:\n                cachedRequests = _context5.sent;\n                cachedRequestsToDelete = cachedRequests.filter(function (cachedRequest) {\n                  return !expectedCacheUrls.includes(new URL(cachedRequest.url, location).toString());\n                });\n                _context5.next = 13;\n                return Promise.all(cachedRequestsToDelete.map(function (cacheUrl) {\n                  return cache.delete(cacheUrl);\n                }));\n\n              case 13:\n                return _context5.abrupt(\"return\", cachedRequestsToDelete.map(function (request) {\n                  return request.url;\n                }));\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _cleanupCache(_x2) {\n        return _cleanupCache2.apply(this, arguments);\n      }\n\n      return _cleanupCache;\n    }()\n    /**\n     * Goes through all entries in indexedDB and removes any that are outdated.\n     *\n     * @private\n     * @param {Array<string>} expectedCacheUrls Array of URLs that are\n     * expected to be cached.\n     * @return {Promise<Array<string>>} Resolves to an array of URLs removed\n     * from indexedDB.\n     */\n\n  }, {\n    key: \"_cleanupDetailsModel\",\n    value: function () {\n      var _cleanupDetailsModel2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(expectedCacheUrls) {\n        var _this3 = this;\n\n        var revisionedEntries, detailsToDelete;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this._precacheDetailsModel._getAllEntries();\n\n              case 2:\n                revisionedEntries = _context6.sent;\n                detailsToDelete = revisionedEntries.filter(function (entry) {\n                  var fullUrl = new URL(entry.value.url, location).toString();\n                  return !expectedCacheUrls.includes(fullUrl);\n                });\n                _context6.next = 6;\n                return Promise.all(detailsToDelete.map(function (entry) {\n                  return _this3._precacheDetailsModel._deleteEntry(entry.primaryKey);\n                }));\n\n              case 6:\n                return _context6.abrupt(\"return\", detailsToDelete.map(function (entry) {\n                  return entry.value.url;\n                }));\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _cleanupDetailsModel(_x3) {\n        return _cleanupDetailsModel2.apply(this, arguments);\n      }\n\n      return _cleanupDetailsModel;\n    }()\n    /**\n     * Returns an array of fully qualified URL's that will be precached.\n     *\n     * @return {Array<string>} An array of URLs.\n     */\n\n  }, {\n    key: \"getCachedUrls\",\n    value: function getCachedUrls() {\n      return Array.from(this._entriesToCacheMap.keys()).map(function (url) {\n        return new URL(url, location).href;\n      });\n    }\n  }]);\n\n  return PrecacheController;\n}();\n\nexport default PrecacheController;","map":null,"metadata":{},"sourceType":"module"}