{"ast":null,"code":"import _regeneratorRuntime from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\nimport pluginEvents from '../models/pluginEvents.mjs';\nimport pluginUtils from '../utils/pluginUtils.mjs';\nimport { WorkboxError } from './WorkboxError.mjs';\nimport { assert } from './assert.mjs';\nimport { executeQuotaErrorCallbacks } from './quota.mjs';\nimport { getFriendlyURL } from './getFriendlyURL.mjs';\nimport { logger } from './logger.mjs';\nimport '../_version.mjs';\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n *\n * @private\n * @memberof module:workbox-core\n */\n\nvar putWrapper = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var _ref2,\n        cacheName,\n        request,\n        response,\n        event,\n        _ref2$plugins,\n        plugins,\n        responseToCache,\n        cache,\n        updatePlugins,\n        oldResponse,\n        _iterator,\n        _step,\n        plugin,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, cacheName = _ref2.cacheName, request = _ref2.request, response = _ref2.response, event = _ref2.event, _ref2$plugins = _ref2.plugins, plugins = _ref2$plugins === void 0 ? [] : _ref2$plugins;\n\n            if (response) {\n              _context.next = 4;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(request.url), \"'.\"));\n            }\n\n            throw new WorkboxError('cache-put-with-no-response', {\n              url: getFriendlyURL(request.url)\n            });\n\n          case 4:\n            _context.next = 6;\n            return _isResponseSafeToCache({\n              request: request,\n              response: response,\n              event: event,\n              plugins: plugins\n            });\n\n          case 6:\n            responseToCache = _context.sent;\n\n            if (responseToCache) {\n              _context.next = 10;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Response '\".concat(getFriendlyURL(request.url), \"' will not be \") + \"cached.\", responseToCache);\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 10:\n            if (!(process.env.NODE_ENV !== 'production')) {\n              _context.next = 13;\n              break;\n            }\n\n            if (!(responseToCache.method && responseToCache.method !== 'GET')) {\n              _context.next = 13;\n              break;\n            }\n\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n              url: getFriendlyURL(request.url),\n              method: responseToCache.method\n            });\n\n          case 13:\n            _context.next = 15;\n            return caches.open(cacheName);\n\n          case 15:\n            cache = _context.sent;\n            updatePlugins = pluginUtils.filter(plugins, pluginEvents.CACHE_DID_UPDATE);\n\n            if (!(updatePlugins.length > 0)) {\n              _context.next = 23;\n              break;\n            }\n\n            _context.next = 20;\n            return matchWrapper({\n              cacheName: cacheName,\n              request: request\n            });\n\n          case 20:\n            _context.t0 = _context.sent;\n            _context.next = 24;\n            break;\n\n          case 23:\n            _context.t0 = null;\n\n          case 24:\n            oldResponse = _context.t0;\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response for \") + \"\".concat(getFriendlyURL(request.url), \".\"));\n            }\n\n            _context.prev = 26;\n            _context.next = 29;\n            return cache.put(request, responseToCache);\n\n          case 29:\n            _context.next = 37;\n            break;\n\n          case 31:\n            _context.prev = 31;\n            _context.t1 = _context[\"catch\"](26);\n\n            if (!(_context.t1.name === 'QuotaExceededError')) {\n              _context.next = 36;\n              break;\n            }\n\n            _context.next = 36;\n            return executeQuotaErrorCallbacks();\n\n          case 36:\n            throw _context.t1;\n\n          case 37:\n            _iterator = _createForOfIteratorHelper(updatePlugins);\n            _context.prev = 38;\n\n            _iterator.s();\n\n          case 40:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 46;\n              break;\n            }\n\n            plugin = _step.value;\n            _context.next = 44;\n            return plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n              cacheName: cacheName,\n              request: request,\n              event: event,\n              oldResponse: oldResponse,\n              newResponse: responseToCache\n            });\n\n          case 44:\n            _context.next = 40;\n            break;\n\n          case 46:\n            _context.next = 51;\n            break;\n\n          case 48:\n            _context.prev = 48;\n            _context.t2 = _context[\"catch\"](38);\n\n            _iterator.e(_context.t2);\n\n          case 51:\n            _context.prev = 51;\n\n            _iterator.f();\n\n            return _context.finish(51);\n\n          case 54:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[26, 31], [38, 48, 51, 54]]);\n  }));\n\n  return function putWrapper() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *.    cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nvar matchWrapper = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n    var cacheName, request, event, matchOptions, _ref3$plugins, plugins, cache, cachedResponse, _iterator2, _step2, plugin;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            cacheName = _ref3.cacheName, request = _ref3.request, event = _ref3.event, matchOptions = _ref3.matchOptions, _ref3$plugins = _ref3.plugins, plugins = _ref3$plugins === void 0 ? [] : _ref3$plugins;\n            _context2.next = 3;\n            return caches.open(cacheName);\n\n          case 3:\n            cache = _context2.sent;\n            _context2.next = 6;\n            return cache.match(request, matchOptions);\n\n          case 6:\n            cachedResponse = _context2.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (cachedResponse) {\n                logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n              } else {\n                logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n              }\n            }\n\n            _iterator2 = _createForOfIteratorHelper(plugins);\n            _context2.prev = 9;\n\n            _iterator2.s();\n\n          case 11:\n            if ((_step2 = _iterator2.n()).done) {\n              _context2.next = 20;\n              break;\n            }\n\n            plugin = _step2.value;\n\n            if (!(pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin)) {\n              _context2.next = 18;\n              break;\n            }\n\n            _context2.next = 16;\n            return plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED].call(plugin, {\n              cacheName: cacheName,\n              request: request,\n              event: event,\n              matchOptions: matchOptions,\n              cachedResponse: cachedResponse\n            });\n\n          case 16:\n            cachedResponse = _context2.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (cachedResponse) {\n                assert.isInstance(cachedResponse, Response, {\n                  moduleName: 'Plugin',\n                  funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 18:\n            _context2.next = 11;\n            break;\n\n          case 20:\n            _context2.next = 25;\n            break;\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](9);\n\n            _iterator2.e(_context2.t0);\n\n          case 25:\n            _context2.prev = 25;\n\n            _iterator2.f();\n\n            return _context2.finish(25);\n\n          case 28:\n            return _context2.abrupt(\"return\", cachedResponse);\n\n          case 29:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[9, 22, 25, 28]]);\n  }));\n\n  return function matchWrapper(_x) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * response.ok) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\n\nvar _isResponseSafeToCache = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5) {\n    var request, response, event, plugins, responseToCache, pluginsUsed, _iterator3, _step3, plugin;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            request = _ref5.request, response = _ref5.response, event = _ref5.event, plugins = _ref5.plugins;\n            responseToCache = response;\n            pluginsUsed = false;\n            _iterator3 = _createForOfIteratorHelper(plugins);\n            _context3.prev = 4;\n\n            _iterator3.s();\n\n          case 6:\n            if ((_step3 = _iterator3.n()).done) {\n              _context3.next = 18;\n              break;\n            }\n\n            plugin = _step3.value;\n\n            if (!(pluginEvents.CACHE_WILL_UPDATE in plugin)) {\n              _context3.next = 16;\n              break;\n            }\n\n            pluginsUsed = true;\n            _context3.next = 12;\n            return plugin[pluginEvents.CACHE_WILL_UPDATE].call(plugin, {\n              request: request,\n              response: responseToCache,\n              event: event\n            });\n\n          case 12:\n            responseToCache = _context3.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (responseToCache) {\n                assert.isInstance(responseToCache, Response, {\n                  moduleName: 'Plugin',\n                  funcName: pluginEvents.CACHE_WILL_UPDATE,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n            if (responseToCache) {\n              _context3.next = 16;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 18);\n\n          case 16:\n            _context3.next = 6;\n            break;\n\n          case 18:\n            _context3.next = 23;\n            break;\n\n          case 20:\n            _context3.prev = 20;\n            _context3.t0 = _context3[\"catch\"](4);\n\n            _iterator3.e(_context3.t0);\n\n          case 23:\n            _context3.prev = 23;\n\n            _iterator3.f();\n\n            return _context3.finish(23);\n\n          case 26:\n            if (!pluginsUsed) {\n              if (process.env.NODE_ENV !== 'production') {\n                if (!responseToCache.ok) {\n                  if (responseToCache.status === 0) {\n                    logger.warn(\"The response for '\".concat(request.url, \"' is an opaque \") + \"response. The caching strategy that you're using will not \" + \"cache opaque responses by default.\");\n                  } else {\n                    logger.debug(\"The response for '\".concat(request.url, \"' returned \") + \"a status code of '\".concat(response.status, \"' and won't be cached as a \") + \"result.\");\n                  }\n                }\n              }\n\n              responseToCache = responseToCache.ok ? responseToCache : null;\n            }\n\n            return _context3.abrupt(\"return\", responseToCache ? responseToCache : null);\n\n          case 28:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 20, 23, 26]]);\n  }));\n\n  return function _isResponseSafeToCache(_x2) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar cacheWrapper = {\n  put: putWrapper,\n  match: matchWrapper\n};\nexport { cacheWrapper };","map":null,"metadata":{},"sourceType":"module"}