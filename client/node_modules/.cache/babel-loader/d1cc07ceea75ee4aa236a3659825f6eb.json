{"ast":null,"code":"import _regeneratorRuntime from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\nimport '../_version.mjs';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\n\nvar DBWrapper = /*#__PURE__*/function () {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {function(this:DBWrapper, Event)} [callbacks.onupgradeneeded]\n   * @param {function(this:DBWrapper, Event)} [callbacks.onversionchange]\n   *     Defaults to DBWrapper.prototype._onversionchange when not specified.\n   */\n  function DBWrapper(name, version) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        onupgradeneeded = _ref.onupgradeneeded,\n        _ref$onversionchange = _ref.onversionchange,\n        onversionchange = _ref$onversionchange === void 0 ? this._onversionchange : _ref$onversionchange;\n\n    _classCallCheck(this, DBWrapper);\n\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange; // If this is null, it means the database isn't open.\n\n    this._db = null;\n  }\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   *\n   * @private\n   */\n\n\n  _createClass(DBWrapper, [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._db) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.next = 4;\n                return new Promise(function (resolve, reject) {\n                  // This flag is flipped to true if the timeout callback runs prior\n                  // to the request failing or succeeding. Note: we use a timeout instead\n                  // of an onblocked handler since there are cases where onblocked will\n                  // never never run. A timeout better handles all possible scenarios:\n                  // https://github.com/w3c/IndexedDB/issues/223\n                  var openRequestTimedOut = false;\n                  setTimeout(function () {\n                    openRequestTimedOut = true;\n                    reject(new Error('The open request was blocked and timed out'));\n                  }, _this.OPEN_TIMEOUT);\n                  var openRequest = indexedDB.open(_this._name, _this._version);\n\n                  openRequest.onerror = function (evt) {\n                    return reject(openRequest.error);\n                  };\n\n                  openRequest.onupgradeneeded = function (evt) {\n                    if (openRequestTimedOut) {\n                      openRequest.transaction.abort();\n                      evt.target.result.close();\n                    } else if (_this._onupgradeneeded) {\n                      _this._onupgradeneeded(evt);\n                    }\n                  };\n\n                  openRequest.onsuccess = function (evt) {\n                    var db = evt.target.result;\n\n                    if (openRequestTimedOut) {\n                      db.close();\n                    } else {\n                      db.onversionchange = _this._onversionchange;\n                      resolve(db);\n                    }\n                  };\n                });\n\n              case 4:\n                this._db = _context.sent;\n                return _context.abrupt(\"return\", this);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Delegates to the native `get()` method for the object store.\n     *\n     * @param {string} storeName The name of the object store to put the value.\n     * @param {...*} args The values passed to the delegated method.\n     * @return {*} The key of the entry.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(storeName) {\n        var _len,\n            args,\n            _key,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                for (_len = _args2.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  args[_key - 1] = _args2[_key];\n                }\n\n                _context2.next = 3;\n                return this._call.apply(this, ['get', storeName, 'readonly'].concat(args));\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Delegates to the native `add()` method for the object store.\n     *\n     * @param {string} storeName The name of the object store to put the value.\n     * @param {...*} args The values passed to the delegated method.\n     * @return {*} The key of the entry.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(storeName) {\n        var _len2,\n            args,\n            _key2,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                for (_len2 = _args3.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                  args[_key2 - 1] = _args3[_key2];\n                }\n\n                _context3.next = 3;\n                return this._call.apply(this, ['add', storeName, 'readwrite'].concat(args));\n\n              case 3:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function add(_x2) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Delegates to the native `put()` method for the object store.\n     *\n     * @param {string} storeName The name of the object store to put the value.\n     * @param {...*} args The values passed to the delegated method.\n     * @return {*} The key of the entry.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(storeName) {\n        var _len3,\n            args,\n            _key3,\n            _args4 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                for (_len3 = _args4.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                  args[_key3 - 1] = _args4[_key3];\n                }\n\n                _context4.next = 3;\n                return this._call.apply(this, ['put', storeName, 'readwrite'].concat(args));\n\n              case 3:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function put(_x3) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Delegates to the native `delete()` method for the object store.\n     *\n     * @param {string} storeName\n     * @param {...*} args The values passed to the delegated method.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(storeName) {\n        var _len4,\n            args,\n            _key4,\n            _args5 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                for (_len4 = _args5.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                  args[_key4 - 1] = _args5[_key4];\n                }\n\n                _context5.next = 3;\n                return this._call.apply(this, ['delete', storeName, 'readwrite'].concat(args));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _delete(_x4) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * Deletes the underlying database, ensuring that any open connections are\n     * closed first.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"deleteDatabase\",\n    value: function () {\n      var _deleteDatabase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this.close();\n                this._db = null;\n                _context6.next = 4;\n                return new Promise(function (resolve, reject) {\n                  var request = indexedDB.deleteDatabase(_this2._name);\n\n                  request.onerror = function (evt) {\n                    return reject(evt.target.error);\n                  };\n\n                  request.onblocked = function () {\n                    return reject(new Error('Deletion was blocked.'));\n                  };\n\n                  request.onsuccess = function () {\n                    return resolve();\n                  };\n                });\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function deleteDatabase() {\n        return _deleteDatabase.apply(this, arguments);\n      }\n\n      return deleteDatabase;\n    }()\n    /**\n     * Delegates to the native `getAll()` or polyfills it via the `find()`\n     * method in older browsers.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function () {\n      var _getAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(storeName, query, count) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!('getAll' in IDBObjectStore.prototype)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                _context7.next = 3;\n                return this._call('getAll', storeName, 'readonly', query, count);\n\n              case 3:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 6:\n                _context7.next = 8;\n                return this.getAllMatching(storeName, {\n                  query: query,\n                  count: count\n                });\n\n              case 8:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getAll(_x5, _x6, _x7) {\n        return _getAll.apply(this, arguments);\n      }\n\n      return getAll;\n    }()\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {*} [opts.query]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"getAllMatching\",\n    value: function () {\n      var _getAllMatching = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(storeName) {\n        var opts,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                _context8.next = 3;\n                return this.transaction([storeName], 'readonly', function (stores, done) {\n                  var store = stores[storeName];\n                  var target = opts.index ? store.index(opts.index) : store;\n                  var results = []; // Passing `undefined` arguments to Edge's `openCursor(...)` causes\n                  // 'DOMException: DataError'\n                  // Details in issue: https://github.com/GoogleChrome/workbox/issues/1509\n\n                  var query = opts.query || null;\n                  var direction = opts.direction || 'next';\n\n                  target.openCursor(query, direction).onsuccess = function (evt) {\n                    var cursor = evt.target.result;\n\n                    if (cursor) {\n                      var primaryKey = cursor.primaryKey,\n                          key = cursor.key,\n                          value = cursor.value;\n                      results.push(opts.includeKeys ? {\n                        primaryKey: primaryKey,\n                        key: key,\n                        value: value\n                      } : value);\n\n                      if (opts.count && results.length >= opts.count) {\n                        done(results);\n                      } else {\n                        cursor.continue();\n                      }\n                    } else {\n                      done(results);\n                    }\n                  };\n                });\n\n              case 3:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getAllMatching(_x8) {\n        return _getAllMatching.apply(this, arguments);\n      }\n\n      return getAllMatching;\n    }()\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with three arguments:\n     *   1. An object mapping object store names to IDBObjectStore values.\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done.\n     *   3. An `abort` function that can be called to abort the transaction\n     *      at any time.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {function(Object, function(), function(*)):?IDBRequest} callback\n     * @return {*} The result of the transaction ran by the callback.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"transaction\",\n    value: function () {\n      var _transaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(storeNames, type, callback) {\n        var _this3 = this;\n\n        var result;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.open();\n\n              case 2:\n                _context9.next = 4;\n                return new Promise(function (resolve, reject) {\n                  var txn = _this3._db.transaction(storeNames, type);\n\n                  var done = function done(value) {\n                    return resolve(value);\n                  };\n\n                  var abort = function abort() {\n                    reject(new Error('The transaction was manually aborted'));\n                    txn.abort();\n                  };\n\n                  txn.onerror = function (evt) {\n                    return reject(evt.target.error);\n                  };\n\n                  txn.onabort = function (evt) {\n                    return reject(evt.target.error);\n                  };\n\n                  txn.oncomplete = function () {\n                    return resolve();\n                  };\n\n                  var stores = {};\n\n                  var _iterator = _createForOfIteratorHelper(storeNames),\n                      _step;\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      var storeName = _step.value;\n                      stores[storeName] = txn.objectStore(storeName);\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n\n                  callback(stores, done, abort);\n                });\n\n              case 4:\n                result = _context9.sent;\n                return _context9.abrupt(\"return\", result);\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function transaction(_x9, _x10, _x11) {\n        return _transaction.apply(this, arguments);\n      }\n\n      return transaction;\n    }()\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_call\",\n    value: function () {\n      var _call2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(method, storeName, type) {\n        var _len5,\n            args,\n            _key5,\n            callback,\n            _args10 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                for (_len5 = _args10.length, args = new Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n                  args[_key5 - 3] = _args10[_key5];\n                }\n\n                _context10.next = 3;\n                return this.open();\n\n              case 3:\n                callback = function callback(stores, done) {\n                  var _stores$storeName;\n\n                  (_stores$storeName = stores[storeName])[method].apply(_stores$storeName, args).onsuccess = function (evt) {\n                    done(evt.target.result);\n                  };\n                };\n\n                _context10.next = 6;\n                return this.transaction([storeName], type, callback);\n\n              case 6:\n                return _context10.abrupt(\"return\", _context10.sent);\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _call(_x12, _x13, _x14) {\n        return _call2.apply(this, arguments);\n      }\n\n      return _call;\n    }()\n    /**\n     * The default onversionchange handler, which closes the database so other\n     * connections can open without being blocked.\n     *\n     * @param {Event} evt\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_onversionchange\",\n    value: function _onversionchange(evt) {\n      this.close();\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._db) this._db.close();\n    }\n  }]);\n\n  return DBWrapper;\n}(); // Exposed to let users modify the default timeout on a per-instance\n// or global basis.\n\n\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\nexport { DBWrapper };","map":null,"metadata":{},"sourceType":"module"}