{"ast":null,"code":"import _toConsumableArray from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n Copyright 2017 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport normalizeHandler from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\n\nvar Router = /*#__PURE__*/function () {\n  /**\n   * Initializes a new Router.\n   */\n  function Router() {\n    _classCallCheck(this, Router);\n\n    // _routes will contain a mapping of HTTP method name ('GET', etc.) to an\n    // array of all the corresponding Route instances that are registered.\n    this._routes = new Map();\n  }\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {FetchEvent} event The event from a service worker's 'fetch' event\n   * listener.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   * registered route can handle the FetchEvent's request. If there is no\n   * matching route and there's no `defaultHandler`, `undefined` is returned.\n   */\n\n\n  _createClass(Router, [{\n    key: \"handleRequest\",\n    value: function handleRequest(event) {\n      var _this = this;\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(event, FetchEvent, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'handleRequest',\n          paramName: 'event'\n        });\n      }\n\n      var url = new URL(event.request.url);\n\n      if (!url.protocol.startsWith('http')) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"Workbox Router only supports URLs that start with 'http'.\");\n        }\n\n        return;\n      }\n\n      var route = null;\n      var handler = null;\n      var params = null;\n      var debugMessages = [];\n\n      var result = this._findHandlerAndParams(event, url);\n\n      handler = result.handler;\n      params = result.params;\n      route = result.route;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (handler) {\n          debugMessages.push([\"Found a route to handle this request:\", route]);\n\n          if (params) {\n            debugMessages.push([\"Passing the following params to the route's handler:\", params]);\n          }\n        }\n      } // If we don't have a handler because there was no matching route, then\n      // fall back to defaultHandler if that's defined.\n\n\n      if (!handler && this._defaultHandler) {\n        if (process.env.NODE_ENV !== 'production') {\n          debugMessages.push(\"Failed to find a matching route. Falling \" + \"back to the default handler.\"); // This is used for debugging in logs in the case of an error.\n\n          route = '[Default Handler]';\n        }\n\n        handler = this._defaultHandler;\n      }\n\n      if (!handler) {\n        if (process.env.NODE_ENV !== 'production') {\n          // No handler so Workbox will do nothing. If logs is set of debug\n          // i.e. verbose, we should print out this information.\n          logger.debug(\"No route found for: \".concat(getFriendlyURL(url)));\n        }\n\n        return;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        // We have a handler, meaning Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Router is responding to: \".concat(getFriendlyURL(url)));\n        debugMessages.forEach(function (msg) {\n          if (Array.isArray(msg)) {\n            logger.log.apply(logger, _toConsumableArray(msg));\n          } else {\n            logger.log(msg);\n          }\n        }); // The Request and Response objects contains a great deal of information,\n        // hide it under a group in case developers want to see it.\n\n        logger.groupCollapsed(\"View request details here.\");\n        logger.unprefixed.log(event.request);\n        logger.groupEnd();\n        logger.groupEnd();\n      } // Wrap in try and catch in case the handle method throws a synchronous\n      // error. It should still callback to the catch handler.\n\n\n      var responsePromise;\n\n      try {\n        responsePromise = handler.handle({\n          url: url,\n          event: event,\n          params: params\n        });\n      } catch (err) {\n        responsePromise = Promise.reject(err);\n      }\n\n      if (responsePromise && this._catchHandler) {\n        responsePromise = responsePromise.catch(function (err) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to Catch Handler.\"));\n            logger.unprefixed.error(\"Error thrown by:\", route);\n            logger.unprefixed.error(err);\n            logger.groupEnd();\n          }\n\n          return _this._catchHandler.handle({\n            url: url,\n            event: event,\n            err: err\n          });\n        });\n      }\n\n      return responsePromise;\n    }\n    /**\n     * Checks the incoming `event.request` against the registered routes, and if\n     * there's a match, returns the corresponding handler along with any params\n     * generated by the match.\n     *\n     * @param {FetchEvent} event\n     * @param {URL} url\n     * @return {Object} Returns an object with `handler` and `params` properties.\n     * They are populated if a matching route was found or `undefined` otherwise.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_findHandlerAndParams\",\n    value: function _findHandlerAndParams(event, url) {\n      var routes = this._routes.get(event.request.method) || [];\n\n      var _iterator = _createForOfIteratorHelper(routes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var route = _step.value;\n          var matchResult = route.match({\n            url: url,\n            event: event\n          });\n\n          if (matchResult) {\n            if (Array.isArray(matchResult) && matchResult.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              matchResult = undefined;\n            } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0 || matchResult === true) {\n              // Instead of passing an empty object in as params, use undefined.\n              matchResult = undefined;\n            } // Break out of the loop and return the appropriate values as soon as\n            // we have a match.\n\n\n            return {\n              route: route,\n              params: matchResult,\n              handler: route.handler\n            };\n          }\n        } // If we didn't have a match, then return undefined values.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        handler: undefined,\n        params: undefined\n      };\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n\n  }, {\n    key: \"setDefaultHandler\",\n    value: function setDefaultHandler(handler) {\n      this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n\n  }, {\n    key: \"setCatchHandler\",\n    value: function setCatchHandler(handler) {\n      this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox.routing.Route} route The route to register.\n     */\n\n  }, {\n    key: \"registerRoute\",\n    value: function registerRoute(route) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(route, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route, 'match', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.isType(route.handler, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert.hasMethod(route.handler, 'handle', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.handler'\n        });\n        assert.isType(route.method, 'string', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.method'\n        });\n      }\n\n      if (!this._routes.has(route.method)) {\n        this._routes.set(route.method, []);\n      } // Give precedence to all of the earlier routes by adding this additional\n      // route to the end of the array.\n\n\n      this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox.routing.Route} route The route to unregister.\n     */\n\n  }, {\n    key: \"unregisterRoute\",\n    value: function unregisterRoute(route) {\n      if (!this._routes.has(route.method)) {\n        throw new WorkboxError('unregister-route-but-not-found-with-method', {\n          method: route.method\n        });\n      }\n\n      var routeIndex = this._routes.get(route.method).indexOf(route);\n\n      if (routeIndex > -1) {\n        this._routes.get(route.method).splice(routeIndex, 1);\n      } else {\n        throw new WorkboxError('unregister-route-route-not-registered');\n      }\n    }\n  }]);\n\n  return Router;\n}();\n\nexport { Router };","map":null,"metadata":{},"sourceType":"module"}