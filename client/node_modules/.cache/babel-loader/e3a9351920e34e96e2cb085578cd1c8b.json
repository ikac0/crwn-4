{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\nimport { assert } from 'workbox-core/_private/assert.mjs';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.mjs';\nimport { logger } from 'workbox-core/_private/logger.mjs';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.mjs';\nimport PrecacheController from './controllers/PrecacheController.mjs';\nimport './_version.mjs';\n\nif (process.env.NODE_ENV !== 'production') {\n  assert.isSwEnv('workbox-precaching');\n}\n\nvar installActivateListenersAdded = false;\nvar fetchListenersAdded = false;\nvar suppressWarnings = false;\nvar plugins = [];\nvar cacheName = cacheNames.getPrecacheName();\nvar precacheController = new PrecacheController(cacheName);\n\nvar _removeIgnoreUrlParams = function _removeIgnoreUrlParams(origUrlObject, ignoreUrlParametersMatching) {\n  // Exclude initial '?'\n  var searchString = origUrlObject.search.slice(1); // Split into an array of 'key=value' strings\n\n  var keyValueStrings = searchString.split('&');\n  var keyValuePairs = keyValueStrings.map(function (keyValueString) {\n    // Split each 'key=value' string into a [key, value] array\n    return keyValueString.split('=');\n  });\n  var filteredKeyValuesPairs = keyValuePairs.filter(function (keyValuePair) {\n    return ignoreUrlParametersMatching.every(function (ignoredRegex) {\n      // Return true iff the key doesn't match any of the regexes.\n      return !ignoredRegex.test(keyValuePair[0]);\n    });\n  });\n  var filteredStrings = filteredKeyValuesPairs.map(function (keyValuePair) {\n    // Join each [key, value] array into a 'key=value' string\n    return keyValuePair.join('=');\n  }); // Join the array of 'key=value' strings into a string with '&' in\n  // between each\n\n  var urlClone = new URL(origUrlObject);\n  urlClone.search = filteredStrings.join('&');\n  return urlClone;\n};\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string|null} Returns the URL in the cache that matches the request\n * if available, other null.\n *\n * @private\n */\n\n\nvar _getPrecachedUrl = function _getPrecachedUrl(url) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$ignoreUrlParamet = _ref.ignoreUrlParametersMatching,\n      ignoreUrlParametersMatching = _ref$ignoreUrlParamet === void 0 ? [/^utm_/] : _ref$ignoreUrlParamet,\n      _ref$directoryIndex = _ref.directoryIndex,\n      directoryIndex = _ref$directoryIndex === void 0 ? 'index.html' : _ref$directoryIndex,\n      _ref$cleanUrls = _ref.cleanUrls,\n      cleanUrls = _ref$cleanUrls === void 0 ? true : _ref$cleanUrls,\n      _ref$urlManipulation = _ref.urlManipulation,\n      urlManipulation = _ref$urlManipulation === void 0 ? null : _ref$urlManipulation;\n\n  var urlObject = new URL(url, location); // Change '/some-url#123' => '/some-url'\n\n  urlObject.hash = '';\n\n  var urlWithoutIgnoredParams = _removeIgnoreUrlParams(urlObject, ignoreUrlParametersMatching);\n\n  var urlsToAttempt = [// Test the URL that was fetched\n  urlObject, // Test the URL without search params\n  urlWithoutIgnoredParams]; // Test the URL with a directory index\n\n  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n    var directoryUrl = new URL(urlWithoutIgnoredParams);\n    directoryUrl.pathname += directoryIndex;\n    urlsToAttempt.push(directoryUrl);\n  } // Test the URL with a '.html' extension\n\n\n  if (cleanUrls) {\n    var cleanUrl = new URL(urlWithoutIgnoredParams);\n    cleanUrl.pathname += '.html';\n    urlsToAttempt.push(cleanUrl);\n  }\n\n  if (urlManipulation) {\n    var additionalUrls = urlManipulation({\n      url: urlObject\n    });\n    urlsToAttempt = urlsToAttempt.concat(additionalUrls);\n  }\n\n  var cachedUrls = precacheController.getCachedUrls();\n\n  var _iterator = _createForOfIteratorHelper(urlsToAttempt),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var possibleUrl = _step.value;\n\n      if (cachedUrls.indexOf(possibleUrl.href) !== -1) {\n        // It's a perfect match\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"Precaching found a match for \" + getFriendlyURL(possibleUrl.toString()));\n        }\n\n        return possibleUrl.href;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n};\n\nvar moduleExports = {};\n/**\n * Add items to the precache list, removing any duplicates and\n * store the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you,\n * it only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\n\nmoduleExports.precache = function (entries) {\n  precacheController.addToCacheList(entries);\n\n  if (installActivateListenersAdded || entries.length <= 0) {\n    return;\n  }\n\n  installActivateListenersAdded = true;\n  self.addEventListener('install', function (event) {\n    event.waitUntil(precacheController.install({\n      event: event,\n      plugins: plugins,\n      suppressWarnings: suppressWarnings\n    }));\n  });\n  self.addEventListener('activate', function (event) {\n    event.waitUntil(precacheController.activate({\n      event: event,\n      plugins: plugins\n    }));\n  });\n};\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreUrlParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanUrls=true] The `cleanUrls` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URL's that should be checked for precache matches.\n *\n * @alias workbox.precaching.addRoute\n */\n\n\nmoduleExports.addRoute = function (options) {\n  if (fetchListenersAdded) {\n    // TODO: Throw error here.\n    return;\n  }\n\n  fetchListenersAdded = true;\n  self.addEventListener('fetch', function (event) {\n    var precachedUrl = _getPrecachedUrl(event.request.url, options);\n\n    if (!precachedUrl) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"Precaching found no match for \" + getFriendlyURL(event.request.url));\n      }\n\n      return;\n    }\n\n    var responsePromise = caches.open(cacheName).then(function (cache) {\n      return cache.match(precachedUrl);\n    }).then(function (cachedResponse) {\n      if (cachedResponse) {\n        return cachedResponse;\n      } // Fall back to the network if we don't have a cached response (perhaps\n      // due to manual cache cleanup).\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"The precached response for \" + \"\".concat(getFriendlyURL(precachedUrl), \" in \").concat(cacheName, \" was not found. \") + \"Falling back to the network instead.\");\n      }\n\n      return fetch(precachedUrl);\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then(function (response) {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(\"Precaching is responding to: \" + getFriendlyURL(event.request.url));\n        logger.log(\"Serving the precached url: \".concat(precachedUrl)); // The Request and Response objects contains a great deal of\n        // information, hide it under a group in case developers want to see it.\n\n        logger.groupCollapsed(\"View request details here.\");\n        logger.unprefixed.log(event.request);\n        logger.groupEnd();\n        logger.groupCollapsed(\"View response details here.\");\n        logger.unprefixed.log(response);\n        logger.groupEnd();\n        logger.groupEnd();\n        return response;\n      });\n    }\n\n    event.respondWith(responsePromise);\n  });\n};\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} options See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\n\n\nmoduleExports.precacheAndRoute = function (entries, options) {\n  moduleExports.precache(entries);\n  moduleExports.addRoute(options);\n};\n/**\n * Warnings will be logged if any of the precached assets are entered without\n * a `revision` property. This is extremely dangerous if the URL's aren't\n * revisioned. However, the warnings can be supressed with this method.\n *\n * @param {boolean} suppress\n *\n * @alias workbox.precaching.suppressWarnings\n */\n\n\nmoduleExports.suppressWarnings = function (suppress) {\n  suppressWarnings = suppress;\n};\n/**\n * Add plugins to precaching.\n *\n * @param {Array<Object>} newPlugins\n *\n * @alias workbox.precaching.addPlugins\n */\n\n\nmoduleExports.addPlugins = function (newPlugins) {\n  plugins = plugins.concat(newPlugins);\n};\n\nexport default moduleExports;","map":null,"metadata":{},"sourceType":"module"}