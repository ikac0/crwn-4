{"ast":null,"code":"import _regeneratorRuntime from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/krsteski/Desktop/crown-clothing-windows-189/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\nimport { WorkboxError } from './WorkboxError.mjs';\nimport { logger } from './logger.mjs';\nimport { assert } from './assert.mjs';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.mjs';\nimport pluginEvents from '../models/pluginEvents.mjs';\nimport pluginUtils from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nvar wrappedFetch = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var request, fetchOptions, event, _ref$plugins, plugins, possiblePreloadResponse, failedFetchPlugins, originalRequest, _iterator, _step, plugin, pluginFilteredRequest, fetchResponse, _iterator2, _step2, _plugin;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            request = _ref.request, fetchOptions = _ref.fetchOptions, event = _ref.event, _ref$plugins = _ref.plugins, plugins = _ref$plugins === void 0 ? [] : _ref$plugins;\n\n            if (!(event && event.preloadResponse)) {\n              _context.next = 8;\n              break;\n            }\n\n            _context.next = 4;\n            return event.preloadResponse;\n\n          case 4:\n            possiblePreloadResponse = _context.sent;\n\n            if (!possiblePreloadResponse) {\n              _context.next = 8;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.log(\"Using a preloaded navigation response for \" + \"'\".concat(getFriendlyURL(request.url), \"'\"));\n            }\n\n            return _context.abrupt(\"return\", possiblePreloadResponse);\n\n          case 8:\n            if (typeof request === 'string') {\n              request = new Request(request);\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              assert.isInstance(request, Request, {\n                paramName: request,\n                expectedClass: 'Request',\n                moduleName: 'workbox-core',\n                className: 'fetchWrapper',\n                funcName: 'wrappedFetch'\n              });\n            }\n\n            failedFetchPlugins = pluginUtils.filter(plugins, pluginEvents.FETCH_DID_FAIL); // If there is a fetchDidFail plugin, we need to save a clone of the\n            // original request before it's either modified by a requestWillFetch\n            // plugin or before the original request's body is consumed via fetch().\n\n            originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n            _context.prev = 12;\n            _iterator = _createForOfIteratorHelper(plugins);\n            _context.prev = 14;\n\n            _iterator.s();\n\n          case 16:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 25;\n              break;\n            }\n\n            plugin = _step.value;\n\n            if (!(pluginEvents.REQUEST_WILL_FETCH in plugin)) {\n              _context.next = 23;\n              break;\n            }\n\n            _context.next = 21;\n            return plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n              request: request.clone(),\n              event: event\n            });\n\n          case 21:\n            request = _context.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (request) {\n                assert.isInstance(request, Request, {\n                  moduleName: 'Plugin',\n                  funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 23:\n            _context.next = 16;\n            break;\n\n          case 25:\n            _context.next = 30;\n            break;\n\n          case 27:\n            _context.prev = 27;\n            _context.t0 = _context[\"catch\"](14);\n\n            _iterator.e(_context.t0);\n\n          case 30:\n            _context.prev = 30;\n\n            _iterator.f();\n\n            return _context.finish(30);\n\n          case 33:\n            _context.next = 38;\n            break;\n\n          case 35:\n            _context.prev = 35;\n            _context.t1 = _context[\"catch\"](12);\n            throw new WorkboxError('plugin-error-request-will-fetch', {\n              thrownError: _context.t1\n            });\n\n          case 38:\n            // The request can be altered by plugins with `requestWillFetch` making\n            // the original request (Most likely from a `fetch` event) to be different\n            // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n            pluginFilteredRequest = request.clone();\n            _context.prev = 39;\n            _context.next = 42;\n            return fetch(request, fetchOptions);\n\n          case 42:\n            fetchResponse = _context.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' returned a response with \") + \"status '\".concat(fetchResponse.status, \"'.\"));\n            }\n\n            return _context.abrupt(\"return\", fetchResponse);\n\n          case 47:\n            _context.prev = 47;\n            _context.t2 = _context[\"catch\"](39);\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' threw an error.\"), _context.t2);\n            }\n\n            _iterator2 = _createForOfIteratorHelper(failedFetchPlugins);\n            _context.prev = 51;\n\n            _iterator2.s();\n\n          case 53:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 59;\n              break;\n            }\n\n            _plugin = _step2.value;\n            _context.next = 57;\n            return _plugin[pluginEvents.FETCH_DID_FAIL].call(_plugin, {\n              error: _context.t2,\n              event: event,\n              originalRequest: originalRequest.clone(),\n              request: pluginFilteredRequest.clone()\n            });\n\n          case 57:\n            _context.next = 53;\n            break;\n\n          case 59:\n            _context.next = 64;\n            break;\n\n          case 61:\n            _context.prev = 61;\n            _context.t3 = _context[\"catch\"](51);\n\n            _iterator2.e(_context.t3);\n\n          case 64:\n            _context.prev = 64;\n\n            _iterator2.f();\n\n            return _context.finish(64);\n\n          case 67:\n            throw _context.t2;\n\n          case 68:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[12, 35], [14, 27, 30, 33], [39, 47], [51, 61, 64, 67]]);\n  }));\n\n  return function wrappedFetch(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar fetchWrapper = {\n  fetch: wrappedFetch\n};\nexport { fetchWrapper };","map":null,"metadata":{},"sourceType":"module"}